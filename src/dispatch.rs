//! Transport-agnostic request dispatch.
//!
//! This module exposes a small API for feeding raw FUSE request bytes into fuser's
//! existing parser + `Filesystem` dispatch path without requiring `/dev/fuse`.

use std::convert::TryFrom;
use std::io;
use std::io::IoSlice;
use std::os::fd::BorrowedFd;
use std::path::Path;
use std::sync::Arc;

use log::debug;
use nix::unistd::Uid;
use nix::unistd::geteuid;

use crate::BackingId;
use crate::Errno;
use crate::Filesystem;
use crate::KernelConfig;
use crate::RenameFlags;
use crate::Request;
use crate::forget_one::ForgetOne;
use crate::ll;
use crate::ll::ResponseErrno;
use crate::ll::Version;
use crate::ll::fuse_abi as abi;
use crate::reply::Reply;
use crate::reply::ReplyDirectory;
use crate::reply::ReplyDirectoryPlus;
use crate::reply::ReplyEmpty;
use crate::reply::ReplyRaw;
use crate::reply::ReplySender;
use crate::session::SessionACL;

/// Destination for serialized FUSE replies generated by dispatcher calls.
///
/// Implementors typically forward bytes onto an alternate transport (for example,
/// a virtio-fs queue writer). `send()` may be called with multiple iovecs for a
/// single reply message.
pub trait Outbound: Send + Sync + 'static {
    /// Send a serialized FUSE reply.
    fn send(&self, data: &[IoSlice<'_>]) -> io::Result<()>;

    /// Register a passthrough backing file and return its backing id.
    ///
    /// The default implementation returns `ErrorKind::Unsupported`.
    fn open_backing(&self, _fd: BorrowedFd<'_>) -> io::Result<BackingId> {
        Err(io::Error::new(
            io::ErrorKind::Unsupported,
            "open_backing is unsupported",
        ))
    }
}

/// Access-control inputs used by [`handle_request`].
#[derive(Debug, Clone, Copy)]
pub struct DispatchContext {
    /// UID filtering mode (same behavior as session ACL checks).
    pub acl: SessionACL,
    /// UID that owns the serving process.
    pub session_owner_uid: u32,
}

impl DispatchContext {
    /// Create a new context with explicit ACL and owner uid.
    pub fn new(acl: SessionACL, session_owner_uid: u32) -> Self {
        Self {
            acl,
            session_owner_uid,
        }
    }
}

impl Default for DispatchContext {
    fn default() -> Self {
        Self {
            acl: SessionACL::Owner,
            session_owner_uid: geteuid().as_raw(),
        }
    }
}

/// Result of processing one init request with [`handle_init`].
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct InitOutcome {
    /// Kernel ABI version from the incoming init request.
    pub kernel_abi: Version,
    /// Whether initialization completed.
    ///
    /// If `false`, fuser replied with a version-only init response and expects a
    /// follow-up init request with a compatible major version.
    pub completed: bool,
}

/// High-level result of dispatching one non-init request.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum DispatchOutcome {
    /// Continue serving further requests.
    Continue,
    /// A destroy request was handled.
    Destroy,
}

/// Handle a single `FUSE_INIT` request.
///
/// The caller should invoke this before dispatching regular requests.
pub fn handle_init<FS: Filesystem>(
    filesystem: &mut FS,
    request_bytes: &[u8],
    outbound: Arc<dyn Outbound>,
) -> io::Result<InitOutcome> {
    let request = parse_request(request_bytes)?;
    let op = request.operation().map_err(|_| {
        io::Error::new(
            io::ErrorKind::InvalidData,
            "failed to parse FUSE operation for init",
        )
    })?;
    let init = match op {
        ll::Operation::Init(init) => init,
        _ => {
            return Err(io::Error::new(
                io::ErrorKind::InvalidInput,
                "expected FUSE_INIT request",
            ));
        }
    };

    let v = init.version();
    let reply_sender = ReplySender::Outbound(outbound);

    if v.0 > abi::FUSE_KERNEL_VERSION {
        let response = init.reply_version_only();
        <ReplyRaw as Reply>::new(request.unique(), reply_sender).send_ll(&response);
        return Ok(InitOutcome {
            kernel_abi: v,
            completed: false,
        });
    }

    if v < Version(7, 6) {
        <ReplyRaw as Reply>::new(request.unique(), reply_sender)
            .send_ll(&ResponseErrno(Errno::EPROTO));
        return Err(io::Error::new(
            io::ErrorKind::Unsupported,
            format!("unsupported FUSE ABI version {v}"),
        ));
    }

    let mut config = KernelConfig::new(init.capabilities(), init.max_readahead(), v);
    if let Err(error) = filesystem.init(Request::ref_cast(request.header()), &mut config) {
        let errno = Errno::from_i32(error.raw_os_error().unwrap_or(0));
        <ReplyRaw as Reply>::new(request.unique(), reply_sender).send_ll(&ResponseErrno(errno));
        return Err(error);
    }

    let response = init.reply(&config);
    <ReplyRaw as Reply>::new(request.unique(), reply_sender).send_ll(&response);
    Ok(InitOutcome {
        kernel_abi: v,
        completed: true,
    })
}

/// Handle a single non-init request.
///
/// All reply bytes are emitted via `outbound`. For requests that return no reply
/// (`forget`, `batch_forget`), this function only invokes filesystem callbacks.
pub fn handle_request<FS: Filesystem>(
    filesystem: &FS,
    request_bytes: &[u8],
    outbound: Arc<dyn Outbound>,
    context: &DispatchContext,
) -> io::Result<DispatchOutcome> {
    let request = ExternalRequest::new(request_bytes, outbound)?;
    debug!("{}", request.request);
    match request.dispatch_req(filesystem, context) {
        Ok(outcome) => Ok(outcome),
        Err(errno) => {
            request.reply::<ReplyRaw>().send_ll(&ResponseErrno(errno));
            Ok(DispatchOutcome::Continue)
        }
    }
}

fn parse_request<'a>(request_bytes: &'a [u8]) -> io::Result<ll::AnyRequest<'a>> {
    ll::AnyRequest::try_from(request_bytes)
        .map_err(|err| io::Error::new(io::ErrorKind::InvalidData, err.to_string()))
}

struct ExternalRequest<'a> {
    request: ll::AnyRequest<'a>,
    outbound: Arc<dyn Outbound>,
}

impl<'a> ExternalRequest<'a> {
    fn new(request_bytes: &'a [u8], outbound: Arc<dyn Outbound>) -> io::Result<Self> {
        Ok(Self {
            request: parse_request(request_bytes)?,
            outbound,
        })
    }

    fn dispatch_req<FS: Filesystem>(
        &self,
        filesystem: &FS,
        context: &DispatchContext,
    ) -> Result<DispatchOutcome, Errno> {
        let op = self.request.operation().map_err(|_| Errno::ENOSYS)?;
        if !is_acl_allowed(&self.request, context, &op) {
            return Err(Errno::EACCES);
        }

        match op {
            ll::Operation::Init(_) => {
                return Err(Errno::EIO);
            }
            ll::Operation::Destroy(_) => {
                self.reply::<ReplyEmpty>().ok();
                return Ok(DispatchOutcome::Destroy);
            }
            ll::Operation::Interrupt(_) => {
                return Err(Errno::ENOSYS);
            }
            ll::Operation::Lookup(x) => {
                filesystem.lookup(
                    self.request_header(),
                    self.request.nodeid(),
                    x.name().as_ref(),
                    self.reply(),
                );
            }
            ll::Operation::Forget(x) => {
                filesystem.forget(self.request_header(), self.request.nodeid(), x.nlookup());
            }
            ll::Operation::GetAttr(attr) => {
                filesystem.getattr(
                    self.request_header(),
                    self.request.nodeid(),
                    attr.file_handle(),
                    self.reply(),
                );
            }
            ll::Operation::SetAttr(x) => {
                filesystem.setattr(
                    self.request_header(),
                    self.request.nodeid(),
                    x.mode(),
                    x.uid(),
                    x.gid(),
                    x.size(),
                    x.atime(),
                    x.mtime(),
                    x.ctime(),
                    x.file_handle(),
                    x.crtime(),
                    x.chgtime(),
                    x.bkuptime(),
                    x.flags(),
                    self.reply(),
                );
            }
            ll::Operation::ReadLink(_) => {
                filesystem.readlink(self.request_header(), self.request.nodeid(), self.reply());
            }
            ll::Operation::MkNod(x) => {
                filesystem.mknod(
                    self.request_header(),
                    self.request.nodeid(),
                    x.name().as_ref(),
                    x.mode(),
                    x.umask(),
                    x.rdev(),
                    self.reply(),
                );
            }
            ll::Operation::MkDir(x) => {
                filesystem.mkdir(
                    self.request_header(),
                    self.request.nodeid(),
                    x.name().as_ref(),
                    x.mode(),
                    x.umask(),
                    self.reply(),
                );
            }
            ll::Operation::Unlink(x) => {
                filesystem.unlink(
                    self.request_header(),
                    self.request.nodeid(),
                    x.name().as_ref(),
                    self.reply(),
                );
            }
            ll::Operation::RmDir(x) => {
                filesystem.rmdir(
                    self.request_header(),
                    self.request.nodeid(),
                    x.name().as_ref(),
                    self.reply(),
                );
            }
            ll::Operation::SymLink(x) => {
                filesystem.symlink(
                    self.request_header(),
                    self.request.nodeid(),
                    x.link_name().as_ref(),
                    Path::new(x.target()),
                    self.reply(),
                );
            }
            ll::Operation::Rename(x) => {
                filesystem.rename(
                    self.request_header(),
                    self.request.nodeid(),
                    x.src().name.as_ref(),
                    x.dest().dir,
                    x.dest().name.as_ref(),
                    RenameFlags::empty(),
                    self.reply(),
                );
            }
            ll::Operation::Link(x) => {
                filesystem.link(
                    self.request_header(),
                    x.inode_no(),
                    self.request.nodeid(),
                    x.dest().name.as_ref(),
                    self.reply(),
                );
            }
            ll::Operation::Open(x) => {
                filesystem.open(
                    self.request_header(),
                    self.request.nodeid(),
                    x.flags(),
                    self.reply(),
                );
            }
            ll::Operation::Read(x) => {
                filesystem.read(
                    self.request_header(),
                    self.request.nodeid(),
                    x.file_handle(),
                    x.offset()?,
                    x.size(),
                    x.flags(),
                    x.lock_owner(),
                    self.reply(),
                );
            }
            ll::Operation::Write(x) => {
                filesystem.write(
                    self.request_header(),
                    self.request.nodeid(),
                    x.file_handle(),
                    x.offset()?,
                    x.data(),
                    x.write_flags(),
                    x.flags(),
                    x.lock_owner(),
                    self.reply(),
                );
            }
            ll::Operation::Flush(x) => {
                filesystem.flush(
                    self.request_header(),
                    self.request.nodeid(),
                    x.file_handle(),
                    x.lock_owner(),
                    self.reply(),
                );
            }
            ll::Operation::Release(x) => {
                filesystem.release(
                    self.request_header(),
                    self.request.nodeid(),
                    x.file_handle(),
                    x.flags(),
                    x.lock_owner(),
                    x.flush(),
                    self.reply(),
                );
            }
            ll::Operation::FSync(x) => {
                filesystem.fsync(
                    self.request_header(),
                    self.request.nodeid(),
                    x.file_handle(),
                    x.fdatasync(),
                    self.reply(),
                );
            }
            ll::Operation::OpenDir(x) => {
                filesystem.opendir(
                    self.request_header(),
                    self.request.nodeid(),
                    x.flags(),
                    self.reply(),
                );
            }
            ll::Operation::ReadDir(x) => {
                filesystem.readdir(
                    self.request_header(),
                    self.request.nodeid(),
                    x.file_handle(),
                    x.offset(),
                    ReplyDirectory::new(
                        self.request.unique(),
                        ReplySender::Outbound(self.outbound.clone()),
                        x.size() as usize,
                    ),
                );
            }
            ll::Operation::ReleaseDir(x) => {
                filesystem.releasedir(
                    self.request_header(),
                    self.request.nodeid(),
                    x.file_handle(),
                    x.flags(),
                    self.reply(),
                );
            }
            ll::Operation::FSyncDir(x) => {
                filesystem.fsyncdir(
                    self.request_header(),
                    self.request.nodeid(),
                    x.file_handle(),
                    x.fdatasync(),
                    self.reply(),
                );
            }
            ll::Operation::StatFs(_) => {
                filesystem.statfs(self.request_header(), self.request.nodeid(), self.reply());
            }
            ll::Operation::SetXAttr(x) => {
                filesystem.setxattr(
                    self.request_header(),
                    self.request.nodeid(),
                    x.name(),
                    x.value(),
                    x.flags(),
                    x.position(),
                    self.reply(),
                );
            }
            ll::Operation::GetXAttr(x) => {
                filesystem.getxattr(
                    self.request_header(),
                    self.request.nodeid(),
                    x.name(),
                    x.size_u32(),
                    self.reply(),
                );
            }
            ll::Operation::ListXAttr(x) => {
                filesystem.listxattr(
                    self.request_header(),
                    self.request.nodeid(),
                    x.size(),
                    self.reply(),
                );
            }
            ll::Operation::RemoveXAttr(x) => {
                filesystem.removexattr(
                    self.request_header(),
                    self.request.nodeid(),
                    x.name(),
                    self.reply(),
                );
            }
            ll::Operation::Access(x) => {
                filesystem.access(
                    self.request_header(),
                    self.request.nodeid(),
                    x.mask(),
                    self.reply(),
                );
            }
            ll::Operation::Create(x) => {
                filesystem.create(
                    self.request_header(),
                    self.request.nodeid(),
                    x.name().as_ref(),
                    x.mode(),
                    x.umask(),
                    x.flags(),
                    self.reply(),
                );
            }
            ll::Operation::GetLk(x) => {
                filesystem.getlk(
                    self.request_header(),
                    self.request.nodeid(),
                    x.file_handle(),
                    x.lock_owner(),
                    x.lock().range.0,
                    x.lock().range.1,
                    x.lock().typ,
                    x.lock().pid,
                    self.reply(),
                );
            }
            ll::Operation::SetLk(x) => {
                filesystem.setlk(
                    self.request_header(),
                    self.request.nodeid(),
                    x.file_handle(),
                    x.lock_owner(),
                    x.lock().range.0,
                    x.lock().range.1,
                    x.lock().typ,
                    x.lock().pid,
                    x.sleep(),
                    self.reply(),
                );
            }
            ll::Operation::BMap(x) => {
                filesystem.bmap(
                    self.request_header(),
                    self.request.nodeid(),
                    x.block_size(),
                    x.block(),
                    self.reply(),
                );
            }
            ll::Operation::IoCtl(x) => {
                if x.unrestricted() {
                    return Err(Errno::ENOSYS);
                }
                filesystem.ioctl(
                    self.request_header(),
                    self.request.nodeid(),
                    x.file_handle(),
                    x.flags(),
                    x.command(),
                    x.in_data(),
                    x.out_size(),
                    self.reply(),
                );
            }
            ll::Operation::Poll(_) => {
                // Poll notifications currently require a channel-backed notifier.
                return Err(Errno::ENOSYS);
            }
            ll::Operation::NotifyReply(_) => {
                return Err(Errno::ENOSYS);
            }
            ll::Operation::BatchForget(x) => {
                filesystem.batch_forget(
                    self.request_header(),
                    ForgetOne::slice_from_inner(x.nodes()),
                );
            }
            ll::Operation::FAllocate(x) => {
                filesystem.fallocate(
                    self.request_header(),
                    self.request.nodeid(),
                    x.file_handle(),
                    x.offset()?,
                    x.len()?,
                    x.mode(),
                    self.reply(),
                );
            }
            ll::Operation::ReadDirPlus(x) => {
                filesystem.readdirplus(
                    self.request_header(),
                    self.request.nodeid(),
                    x.file_handle(),
                    x.offset(),
                    ReplyDirectoryPlus::new(
                        self.request.unique(),
                        ReplySender::Outbound(self.outbound.clone()),
                        x.size() as usize,
                    ),
                );
            }
            ll::Operation::Rename2(x) => {
                filesystem.rename(
                    self.request_header(),
                    x.from().dir,
                    x.from().name.as_ref(),
                    x.to().dir,
                    x.to().name.as_ref(),
                    x.flags(),
                    self.reply(),
                );
            }
            ll::Operation::Lseek(x) => {
                filesystem.lseek(
                    self.request_header(),
                    self.request.nodeid(),
                    x.file_handle(),
                    x.offset(),
                    x.whence(),
                    self.reply(),
                );
            }
            ll::Operation::CopyFileRange(x) => {
                let (i, o) = (x.src()?, x.dest()?);
                filesystem.copy_file_range(
                    self.request_header(),
                    i.inode,
                    i.file_handle,
                    i.offset,
                    o.inode,
                    o.file_handle,
                    o.offset,
                    x.len(),
                    x.flags(),
                    self.reply(),
                );
            }
            #[cfg(target_os = "macos")]
            ll::Operation::SetVolName(x) => {
                filesystem.setvolname(self.request_header(), x.name(), self.reply());
            }
            #[cfg(target_os = "macos")]
            ll::Operation::GetXTimes(x) => {
                filesystem.getxtimes(self.request_header(), x.nodeid(), self.reply());
            }
            #[cfg(target_os = "macos")]
            ll::Operation::Exchange(x) => {
                filesystem.exchange(
                    self.request_header(),
                    x.from().dir,
                    x.from().name.as_ref(),
                    x.to().dir,
                    x.to().name.as_ref(),
                    x.options(),
                    self.reply(),
                );
            }
            ll::Operation::CuseInit(_) => {
                return Err(Errno::ENOSYS);
            }
        }

        Ok(DispatchOutcome::Continue)
    }

    fn reply<T: Reply>(&self) -> T {
        Reply::new(
            self.request.unique(),
            ReplySender::Outbound(self.outbound.clone()),
        )
    }

    fn request_header(&self) -> &Request {
        Request::ref_cast(self.request.header())
    }
}

fn is_acl_allowed(
    request: &ll::AnyRequest<'_>,
    context: &DispatchContext,
    op: &ll::Operation<'_>,
) -> bool {
    let owner = Uid::from_raw(context.session_owner_uid);
    let uid = request.uid();
    if (context.acl == SessionACL::RootAndOwner && uid != owner && !uid.is_root())
        || (context.acl == SessionACL::Owner && uid != owner)
    {
        return matches!(
            op,
            ll::Operation::Init(_)
                | ll::Operation::Destroy(_)
                | ll::Operation::Read(_)
                | ll::Operation::ReadDir(_)
                | ll::Operation::BatchForget(_)
                | ll::Operation::Forget(_)
                | ll::Operation::Write(_)
                | ll::Operation::FSync(_)
                | ll::Operation::FSyncDir(_)
                | ll::Operation::Release(_)
                | ll::Operation::ReleaseDir(_)
                | ll::Operation::ReadDirPlus(_)
        );
    }
    true
}
